generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "sqlite"
    url      = env("DATABASE_URL")
}

enum UserRole {
    USER
    GUARDIAN
    ADMIN
}

enum AccountStatus {
    LIMITED
    VERIFIED
    BANNED
    ENGAGED
}

enum VerificationStatus {
    PENDING
    VERIFIED
    REJECTED
}

enum InterestStatus {
    PENDING
    ACCEPTED
    REJECTED
    WITHDRAWN
}

enum MessageType {
    TEXT
    IMAGE
    AUDIO
}

model User {
    id            String        @id @default(cuid())
    email         String        @unique
    password      String
    name          String?
    phone         String?
    role          UserRole      @default(USER)
    accountStatus AccountStatus @default(LIMITED)

    // Verification Flags
    emailVerified DateTime?
    phoneVerified Boolean   @default(false)
    photoVerified Boolean   @default(false)
    idVerified    Boolean   @default(false)
    trustScore    Int       @default(0)

    managedById String?
    managedBy   User?   @relation("GuardianManaged", fields: [managedById], references: [id])
    managing    User[]  @relation("GuardianManaged")

    verificationOTP String?
    otpExpires      DateTime?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    profile           Profile?
    sentInterests     Interest[]         @relation("SentInterests")
    receivedInterests Interest[]         @relation("ReceivedInterests")
    matchesAsA        Match[]            @relation("MatchUserA")
    matchesAsB        Match[]            @relation("MatchUserB")
    messages          Message[]
    verifications     Verification[]
    reportsFiled      Report[]           @relation("ReportedBy")
    reportsReceived   Report[]           @relation("ReportedUser")
    blockedUsers      Block[]            @relation("BlockedUsers")
    blockedBy         Block[]            @relation("BlockedBy")
    auditLogs         AuditLog[]
    favorites         Favorite[]         @relation("UserFavorites")
    favoritedBy       Favorite[]         @relation("FavoritedByUser")
    identityDocuments IdentityDocument[]
    notifications     Notification[]
    proposalsSent     Proposal[]         @relation("ProposalsSent")
    proposalsReceived Proposal[]         @relation("ProposalsReceived")

    @@map("users")
}

model Profile {
    id     String @id @default(cuid())
    userId String @unique
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Personal Details
    dateOfBirth  DateTime?
    age          Int?
    gender       String?
    height       Float?
    religion     String?
    caste        String?
    motherTongue String?
    bio          String
    location     String

    // Lifestyle & Profession
    jobStatus      String
    maritalStatus  String
    education      String?
    profession     String?
    incomeRange    String?
    diet           String?
    smoking        String?
    drinking       String?
    jobCategory    String?
    contactDetails String?

    // Family Details
    fatherOccupation String?
    motherOccupation String?
    siblings         String?
    familyType       String?

    // Preferences
    prefAgeMin    Int?
    prefAgeMax    Int?
    prefHeightMin Int?
    prefReligion  String?
    prefEducation String?
    prefLifestyle String?

    // Media
    photoUrl     String
    coverUrl     String?
    photoGallery String?

    completionPercentage Int    @default(0)
    visibility           String @default("PUBLIC")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("profiles")
}

model Interest {
    id         String @id @default(cuid())
    senderId   String
    sender     User   @relation("SentInterests", fields: [senderId], references: [id], onDelete: Cascade)
    receiverId String
    receiver   User   @relation("ReceivedInterests", fields: [receiverId], references: [id], onDelete: Cascade)

    status  InterestStatus @default(PENDING)
    message String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([senderId, receiverId])
    @@map("interests")
}

model Match {
    id      String @id @default(cuid())
    userAId String
    userA   User   @relation("MatchUserA", fields: [userAId], references: [id], onDelete: Cascade)
    userBId String
    userB   User   @relation("MatchUserB", fields: [userBId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())

    messages Message[]

    @@unique([userAId, userBId])
    @@map("matches")
}

model Message {
    id       String @id @default(cuid())
    matchId  String
    match    Match  @relation(fields: [matchId], references: [id], onDelete: Cascade)
    senderId String
    sender   User   @relation(fields: [senderId], references: [id], onDelete: Cascade)

    content String
    type    MessageType @default(TEXT)
    isRead  Boolean     @default(false)

    createdAt DateTime @default(now())

    @@map("messages")
}

model Verification {
    id     String @id @default(cuid())
    userId String
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

    documentType String // "PHOTO", "ID", "PHONE"
    documentUrl  String // Profile photo URL or document URL
    selfieUrl    String? // Verification selfie URL (for photo verification)
    status       VerificationStatus @default(PENDING)
    notes        String? // Admin notes or rejection reason
    reviewedBy   String? // Admin user ID who reviewed
    reviewedAt   DateTime? // Timestamp of review

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("verifications")
}

model Report {
    id         String @id @default(cuid())
    reporterId String
    reporter   User   @relation("ReportedBy", fields: [reporterId], references: [id], onDelete: Cascade)
    targetId   String
    target     User   @relation("ReportedUser", fields: [targetId], references: [id], onDelete: Cascade)

    reason String
    status String @default("OPEN")

    createdAt DateTime @default(now())

    @@map("reports")
}

model Block {
    id        String @id @default(cuid())
    blockerId String
    blocker   User   @relation("BlockedUsers", fields: [blockerId], references: [id], onDelete: Cascade)
    targetId  String
    target    User   @relation("BlockedBy", fields: [targetId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())

    @@unique([blockerId, targetId])
    @@map("blocks")
}

model AuditLog {
    id        String   @id @default(cuid())
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    action    String
    resource  String?
    metadata  String?
    createdAt DateTime @default(now())

    @@map("audit_logs")
}

model Favorite {
    id          String   @id @default(cuid())
    userId      String
    user        User     @relation("UserFavorites", fields: [userId], references: [id], onDelete: Cascade)
    favoritedId String
    favorited   User     @relation("FavoritedByUser", fields: [favoritedId], references: [id], onDelete: Cascade)
    createdAt   DateTime @default(now())

    @@unique([userId, favoritedId])
    @@map("favorites")
}

model IdentityDocument {
    id              String   @id @default(cuid())
    userId          String
    user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    type            String
    fileUrl         String
    status          String   @default("PENDING")
    rejectionReason String?
    createdAt       DateTime @default(now())
    updatedAt       DateTime @updatedAt

    @@map("identity_documents")
}

model Notification {
    id        String   @id @default(cuid())
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    type      String
    title     String
    message   String
    link      String?
    read      Boolean  @default(false)
    createdAt DateTime @default(now())

    @@map("notifications")
}

model Proposal {
    id            String   @id @default(cuid())
    proposerId    String
    proposer      User     @relation("ProposalsSent", fields: [proposerId], references: [id], onDelete: Cascade)
    recipientId   String
    recipient     User     @relation("ProposalsReceived", fields: [recipientId], references: [id], onDelete: Cascade)
    answer        String   @default("PENDING") // YES, NO, PENDING
    message       String?
    adminNotified Boolean  @default(false)
    createdAt     DateTime @default(now())
    updatedAt     DateTime @updatedAt

    @@map("proposals")
}
